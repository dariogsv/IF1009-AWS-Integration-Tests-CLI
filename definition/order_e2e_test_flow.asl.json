{
  "Comment": "Fluxo de Teste E2E Atômico e Genérico",
  "StartAt": "PrepareAndExecuteActions",
  "States": {
    "PrepareAndExecuteActions": {
      "Type": "Map",
      "MaxConcurrency": 1, # Executa ações sequencialmente
      "ItemsPath": "$.actions", # A Step Function receberá um array 'actions' no seu input
      "Iterator": {
        "StartAt": "ExecuteAtomicAction",
        "States": {
          "ExecuteAtomicAction": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Parameters": {
              "FunctionName": "${AtomicLambdaInvokerArn}", # A Lambda que vai executar a ação atômica
              "Payload": {
                "testRunId.$": "$.testRunId", # Passa o ID da execução do teste
                "actionType.$": "$$.Map.Item.Value.type", # Tipo da ação (e.g., "http_call", "dynamodb_interact")
                "actionName.$": "$$.Map.Item.Value.name", # Nome da ação para logs
                "action_params.$": "$$.Map.Item.Value.params", # Parâmetros específicos da ação
                "contextData.$": "$" # Passa o contexto atual para as Lambdas usarem dados de passos anteriores
              }
            },
            "Retry": [
              {
                "ErrorEquals": [ "Lambda.ClientException", "Lambda.SdkClientException", "Lambda.ServiceException", "States.Timeout" ],
                "IntervalSeconds": 5,
                "MaxAttempts": 3,
                "BackoffRate": 2
              }
            ],
            "Catch": [
              {
                "ErrorEquals": [ "States.ALL" ],
                "Next": "ActionFailed",
                "ResultPath": "$.error"
              }
            ],
            "ResultPath": "$.actionResult", # Salva o resultado da ação no payload
            "Next": "HandleActionResult"
          },
          "HandleActionResult": {
            "Type": "Choice",
            "Choices": [
              {
                "Variable": "$.actionResult.status",
                "StringEquals": "FAILED",
                "Next": "ActionFailed"
              }
            ],
            "Default": "Proceed"
          },
          "Proceed": {
            "Type": "Pass",
            "ResultPath": "$$.Map.Item.Value.output", # Adiciona o output da ação ao item original no array 'actions'
            "End": true
          },
          "ActionFailed": {
            "Type": "Fail",
            "Cause.$": "$.error.Cause",
            "Error.$": "$.error.Error"
          }
        }
      },
      "Catch": [ # Se alguma ação no Map falhar, o teste inteiro falha
        {
          "ErrorEquals": [ "States.ALL" ],
          "Next": "TestFailed",
          "ResultPath": "$.error"
        }
      ],
      "ResultPath": "$.finalActionsResult", # Array com resultados de todas as ações
      "Next": "VerifyFinalAssertions"
    },
    "VerifyFinalAssertions": {
      "Type": "Task",
      "Resource": "arn:aws:states:::lambda:invoke",
      "Parameters": {
        "FunctionName": "${AtomicLambdaInvokerArn}",
        "Payload": {
          "testRunId.$": "$.testRunId",
          "actionType": "verify_assertions", # Nova ação para a mesma Lambda
          "action_params.$": "$.assertions", # O objeto de asserções do cenário
          "contextData.$": "$.finalActionsResult" # Passa todos os resultados das ações para a verificação
        }
      },
      "Retry": [ /* ... */ ],
      "Catch": [ /* ... */ ],
      "ResultPath": "$.assertionResult",
      "Next": "CheckOverallTestResult"
    },
    "CheckOverallTestResult": {
      "Type": "Choice",
      "Choices": [
        {
          "Variable": "$.assertionResult.status",
          "StringEquals": "PASSED",
          "Next": "CleanUpTestData"
        }
      ],
      "Default": "TestFailed"
    },
    "CleanUpTestData": {
      "Type": "Map", # Pode ser um Map para múltiplas limpezas
      "MaxConcurrency": 1,
      "ItemsPath": "$.cleanup_actions", # Nova lista de ações de limpeza
      "Iterator": {
        "StartAt": "ExecuteAtomicCleanupAction",
        "States": {
          "ExecuteAtomicCleanupAction": {
            "Type": "Task",
            "Resource": "arn:aws:states:::lambda:invoke",
            "Parameters": {
              "FunctionName": "${AtomicLambdaInvokerArn}",
              "Payload": {
                "testRunId.$": "$.testRunId",
                "actionType.$": "$$.Map.Item.Value.type",
                "actionName.$": "$$.Map.Item.Value.name",
                "action_params.$": "$$.Map.Item.Value.params",
                "contextData.$": "$" # Passa o contexto completo para ajudar na limpeza
              }
            },
            "Catch": [ # Limpeza é best-effort, não falha o teste principal
              {
                "ErrorEquals": [ "States.ALL" ],
                "Next": "CleanupSkipped"
              }
            ],
            "Next": "CleanupSucceeded"
          },
          "CleanupSucceeded": { "Type": "Succeed" }, # Fim da iteração
          "CleanupSkipped": { "Type": "Succeed" } # Fim da iteração
        }
      },
      "ResultPath": "$.cleanupResult",
      "Next": "TestPassed"
    },
    "TestPassed": {
      "Type": "Succeed"
    },
    "TestFailed": {
      "Type": "Fail",
      "Cause.$": "$.error.Cause",
      "Error.$": "$.error.Error"
    }
  }
}